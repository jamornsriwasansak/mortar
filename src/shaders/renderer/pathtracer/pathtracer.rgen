#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

// switch between Heitz's blue-noise and PCG here
//#define USE_PCG
#define USE_BLUE_RAND

#include "common/bluenoise.glsl"
#include "common/bsdf.glsl"
#include "common/math.glsl"
#include "common/onb.glsl"
#include "common/pcg.glsl"
#include "common/traceray.glsl"
#include "shared_rt_stage/hitpayload.glsl"
#include "shared_rt_stage/trimeshlayout.glsl"

layout(location = RAY_PRD_LOCATION) rayPayloadNV HitPayload prd;
layout(location = SHADOW_RAY_PRD_LOCATION) rayPayloadNV bool is_intersect;

layout(set = 0, binding = 0) uniform accelerationStructureNV tlas;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 0, binding = 2) uniform CameraProperties
{
    mat4 m_view;
    mat4 m_proj;
    mat4 m_inv_view;
    mat4 m_inv_proj;
    uvec4 m_is_moved;
} cam;
layout(set = 0, binding = 3) uniform sampler2D envmap;

DECLARE_TRIMESH_LAYOUT(1)
DECLARE_EMITTER_LAYOUT(2)
DECLARE_BLUENOISE_LAYOUT(3)

Ray
generate_primary_ray(const vec2 samples)
{
    const vec2 pixel_center = vec2(gl_LaunchIDNV.xy) + samples;
    const vec2 ndc = pixel_center / vec2(gl_LaunchSizeNV.xy);
    const vec2 d = ndc * 2 - 1;

    const vec3 origin = (cam.m_inv_view * vec4(0, 0, 0, 1)).xyz;
    const vec3 lookat = (cam.m_inv_proj * vec4(d.x, d.y, 1, 1)).xyz;
    const vec3 direction = (cam.m_inv_view * vec4(normalize(lookat), 0)).xyz;

    Ray result;
    result.m_origin = origin;
    result.m_tmin = DEFAULT_TMIN;
    result.m_direction = normalize(direction);
    result.m_tmax = DEFAULT_TMAX;

    return result;
}

vec3 ray_origin;

vec3
connect_emitter_sample(const vec3 position,
                       const vec3 snormal,
                       const vec3 gnormal,
                       const vec3 incoming,
                       const Material material,
                       const EmitterSample emitter_sample)
{
	if (emitter_sample.m_flag == EMITTER_GEOMETRY)
	{
        const vec3 s_to_e = emitter_sample.m_position - position; // surface to emitter
        const float sqr_length = dot(s_to_e, s_to_e);
        const float len = sqrt(sqr_length);
        const vec3 norm_s_to_e = s_to_e / len;

        // check cosine(s_to_e) * cosine(e_to_s)
        const float cos_cos = abs(dot(norm_s_to_e, snormal) * dot(norm_s_to_e, emitter_sample.m_gnormal));
        if (cos_cos <= SMALL_VALUE) { return vec3(0.0f); }

        // test shadow ray
        Ray shadow_ray = Ray_create(position, s_to_e, DEFAULT_TMIN, 1.0f - DEFAULT_TMIN);
        is_intersect = true;
        trace_shadow_ray(shadow_ray, tlas, 1);
        if (is_intersect) { return vec3(0.0f); }

        // evaluate material
        Onb onb = Onb_create(snormal);
        const vec3 bsdf_local_incoming = Onb_to_local(onb, incoming);
        const vec3 bsdf_local_outgoing = Onb_to_local(onb, norm_s_to_e);
        vec3 bsdf_contrib; 
        if (!Material_eval(bsdf_contrib, material, bsdf_local_incoming, bsdf_local_outgoing)) { return vec3(0.0f); }

        return bsdf_contrib * cos_cos / sqr_length * emitter_sample.m_emission / emitter_sample.m_pdf;
    }
    else
	{
		return vec3(0.0f);
	}
}

vec3
li(Ray ray,
   const int sample_index)
{
    EmitterSample emitter_sample = sample_emitter(rand2());

    float ior = 1.0f; // air IOR = 1.0
    vec3 radiance = vec3(0.0f);
    vec3 importance = vec3(1.0f);

    vec2 samples = rand2();
    float next_sample = rand();

    for (int i = 0; i < 2; i++)
    {
        const vec3 incoming = -ray.m_direction;

        // trace ray
		trace_ray(ray, tlas, 0);

		// determine whether we should temrinate or not
		if (prd.m_t < 0)
		{
            // fetch emissive value from envmap
            vec2 latlong_texcoord = latlong_texcoord_from_direction(ray.m_direction);
            vec3 emission = texture(envmap, latlong_texcoord).xyz;
			radiance += importance * emission;
			break;
		}

		// compute position
		const vec3 position = ray.m_direction * prd.m_t + ray.m_origin;

        #if 0
        // compute contribution from next event estimation
        ray_origin = ray.m_origin;
        const vec3 nee_contrib = connect_emitter_sample(position, prd.m_snormal, prd.m_gnormal, incoming, prd.m_material, emitter_sample);
        radiance += nee_contrib;
        break;
        #endif

        // add radiance
        radiance += importance * prd.m_material.m_emission;

		// generate outgoing direction
		Onb onb = Onb_create(prd.m_snormal);
        const vec3 local_incoming = Onb_to_local(onb, incoming);
		vec3 local_outgoing;
        vec3 bsdf_cos_contrib;
		const bool sample_success = Material_cos_sample(local_outgoing, // out
                                                        bsdf_cos_contrib, // out
                                                        ior, // inout
                                                        prd.m_material,
                                                        local_incoming,
                                                        samples,
                                                        next_sample);
		const vec3 outgoing = Onb_to_world(onb, local_outgoing);

        // break if could not sample
        if (!sample_success) { break; }

        // prevent light leak but introduce black fringe
        if (local_outgoing.y * dot(outgoing, prd.m_gnormal) < 0.0f || local_incoming.y * dot(incoming, prd.m_gnormal) < 0.0f)
        {
			break;
        }

        // update importance for the next bounce (veach thesis page 158, figure 5.6)
		importance *= bsdf_cos_contrib;

        // update next_samples
        samples = vec2(next_sample, rand());
        next_sample = rand();

        // update ray
        ray.m_origin = position;
        ray.m_direction = outgoing;
	}
    return radiance;
}

void
main() 
{
    // if camera is not moved reuse accumulated radiance
    vec3 accumulated_radiance = vec3(0.0f);
    float num_spp = 0.0f;

    if (!(cam.m_is_moved.x == 1))
    {
		vec4 accumulated_radiance_and_num_spp = imageLoad(image, ivec2(gl_LaunchIDNV.xy));
		accumulated_radiance = accumulated_radiance_and_num_spp.xyz;
        num_spp = accumulated_radiance_and_num_spp.w;
    }

    // init rng
    srand(uvec2(gl_LaunchIDNV), uvec2(gl_LaunchSizeNV), uint(num_spp));

    float sum = 0.0f;

	// trace ray based on camera properties
	Ray initial_ray = generate_primary_ray(rand2());

    // estimate the radiance and accumulate it.
    vec3 estimated_radiance = li(initial_ray, int(num_spp));

    // accumulate the sample
    accumulated_radiance = ((accumulated_radiance * num_spp) + estimated_radiance) / (num_spp + 1.0f);

	// determine whether we should temrinate or not
	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(accumulated_radiance, num_spp + 1.0f));
}
